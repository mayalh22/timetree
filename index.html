<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Time Tree</title>
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link
  href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"
  rel="stylesheet"
>
<style>
:root {
  --color-bg-dark: hsl(88, 83%, 80%);
  --color-text-light: #ace67d;
  --color-green-accent: #efbac0;
  --color-green-subtle: #1e952a;
  --font-pixel: 'Press Start 2P', monospace;
}
.display-container {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
}
  body {
    background: var(--color-bg-dark);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    margin: 0;
    font-family: var(--font-pixel);
    color: var(--color-text-light);
    padding: 1rem;
    box-sizing: border-box;
  }
  h1 {
    font-size: 2rem;
    margin-bottom: 2.5rem;
  }
  .controls {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1.25rem;
    margin-bottom: 2.5rem;
  }
  input,
  button {
    font-size: 0.9rem;
    font-family: var(--font-pixel);
    background-color: var(--color-green-accent);
    color: var(--color-text-light);
    border: 2px solid var(--color-green-subtle);
    padding: 0.8rem 1.1rem;
    border-radius: 6px;
    cursor: pointer;
    text-transform: uppercase;
    transition: background-color 0.2s, border-color 0.2s;
    outline: none;
  }
  input {
    text-align: center;
    max-width: 150px;
    background-color: transparent;
  }
  input::placeholder {
    color: var(--color-green-subtle);
    opacity: 0.8;
  }
  input:focus,
  button:hover,
  button:focus {
    background-color: var(--color-green-subtle);
    border-color: var(--color-text-light);
    color: var(--color-bg-dark);
  }
  select {
    font-family: var(--font-pixel);
    background-color: var(--color-green-accent);
    color: var(--color-text-light);
    border: 2px solid var(--color-green-subtle);
    padding: 0.4rem 0.6rem;
    border-radius: 6px;
    outline: none;
  }
  button:disabled {
    cursor: not-allowed;
    opacity: 0.6;
  }
  canvas {
    image-rendering: pixelated;
    background: var(--color-green-accent);
    margin-top: 1rem;
    border: 2px solid var(--color-green-subtle);
    /* shadows removed per request */
    box-shadow: none;
    max-width: 100%;
    height: auto;
  }
  .display-container {
    width: 100%;
    max-width: 900px;
    padding: 1rem;
    box-sizing: border-box;
  }
  @media (max-width: 600px) {
    .display-container {
      flex-direction: column;
      gap: 1.75rem;
    }
  }
</style>
</head>
<body>
  <h1>Time Tree</h1>
  <div class="display-container">
  <canvas id="timerCanvas" width="300" height="200"></canvas>
  <canvas id="treeCanvas" width="100" height="200"></canvas>
</div>
  <div class="controls">
    <input
      id="inputSeconds"
      type="number"
      min="1"
      placeholder="Time in seconds"
      aria-label="Enter time in seconds"
    />
    <div>
      <button id="startPauseBtn" aria-label="Start or Pause Timer">Start</button>
      <button id="resetBtn" aria-label="Reset Timer">Reset</button>
      <button id="musicBtn" aria-label="Toggle background music">Play Music</button>
      <button id="loadMusicBtn" aria-label="Load local music file" style="font-size:0.7rem;padding:0.5rem;">Load Music</button>
    </div>
    <div id="timeLive" aria-live="polite" style="position: absolute; left: -9999px; top: auto; width: 1px; height: 1px; overflow: hidden;">00:00:00</div>
    <div style="margin-top:0.6rem;display:flex;gap:0.6rem;align-items:center;">
      <label for="seasonSelect" style="font-size:0.7rem;opacity:0.9;margin:0;">Season</label>
      <select id="seasonSelect" aria-label="Season">
        <option value="spring">Spring</option>
        <option value="summer" selected>Summer</option>
        <option value="autumn">Autumn</option>
        <option value="winter">Winter</option>
      </select>
    </div>
  </div>
  <audio id="bgMusic" loop crossorigin="anonymous" preload="auto">
    <source src="https://cdn.pixabay.com/download/audio/2022/03/03/audio_2d59e2f48f.mp3?filename=relaxing-music-ambient-3781.mp3" type="audio/mpeg" />
  </audio>
  <input id="musicFile" type="file" accept="audio/*" style="display:none;" />
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const $ = id => document.getElementById(id);
      const startPauseBtn = $('startPauseBtn');
      const resetBtn = $('resetBtn');
      const input = $('inputSeconds');
      const musicBtn = $('musicBtn');
      const bgMusic = $('bgMusic');
      const timerCanvas = $('timerCanvas'); const timerCtx = timerCanvas.getContext('2d');
      const treeCanvas = $('treeCanvas'); const treeCtx = treeCanvas.getContext('2d');
      const seasonSelect = $('seasonSelect');

      let PIXEL_SIZE = 12, FONT_COLOR = '#e0f8cf', DIGIT_WIDTH = 5, DIGIT_HEIGHT = 7;
      let countdownInterval, isRunning = false, timeLeft = 0, totalSeconds = 0;
      let maxTreeHeight = 0, treeHeight = 0, pausedTime = 0, startTime = 0;
      let animationId = null, leaves = [], leafFallActive = false;
      let audioCtx = null;
      const ensureAudio = () => {
        if (!audioCtx) try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e){ audioCtx = null; }
        return audioCtx;
      };
      let bgSynthNodes = null;
      let bgSynthActive = false;
      let remoteMusicAvailable = false;
      const startBgSynth = () => {
        const ctx = ensureAudio(); if (!ctx) return;
        if (bgSynthActive) return; bgSynthActive = true;
        const master = ctx.createGain(); master.gain.value = 0.0001; master.connect(ctx.destination);
        master.gain.linearRampToValueAtTime(0.06, ctx.currentTime + 0.8);
        const osc1 = ctx.createOscillator(); osc1.type = 'sine'; osc1.frequency.value = 220;
        const osc2 = ctx.createOscillator(); osc2.type = 'triangle'; osc2.frequency.value = 110;
        const mix = ctx.createGain(); mix.gain.value = 0.6; osc1.connect(mix); osc2.connect(mix);
        const filter = ctx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 800;
        mix.connect(filter); filter.connect(master);
        const lfo = ctx.createOscillator(); lfo.type = 'sine'; lfo.frequency.value = 0.08;
        const lfoGain = ctx.createGain(); lfoGain.gain.value = 400; lfo.connect(lfoGain); lfoGain.connect(filter.frequency);
        osc1.start(); osc2.start(); lfo.start();
        bgSynthNodes = { master, osc1, osc2, mix, filter, lfo, lfoGain };
      };
      const stopBgSynth = () => {
        const ctx = audioCtx; if (!ctx || !bgSynthActive || !bgSynthNodes) return; bgSynthActive = false;
        const now = ctx.currentTime;
        try { bgSynthNodes.master.gain.cancelScheduledValues(now); bgSynthNodes.master.gain.linearRampToValueAtTime(0.0001, now+0.6); } catch(e){}
        setTimeout(()=>{
          try { bgSynthNodes.osc1.stop(); bgSynthNodes.osc2.stop(); bgSynthNodes.lfo.stop(); } catch(e){}
          try { bgSynthNodes.osc1.disconnect(); bgSynthNodes.osc2.disconnect(); bgSynthNodes.lfo.disconnect(); bgSynthNodes.lfoGain.disconnect(); bgSynthNodes.filter.disconnect(); bgSynthNodes.mix.disconnect(); bgSynthNodes.master.disconnect(); } catch(e){}
          bgSynthNodes = null;
        }, 700);
      };
      const playFinishChime = () => {
        const ctx = ensureAudio(); if (!ctx) return;
        const notes = [880,1100,1320], now = ctx.currentTime;
        const m = ctx.createGain(); m.gain.setValueAtTime(0.001, now); m.gain.linearRampToValueAtTime(0.12, now+0.02); m.gain.linearRampToValueAtTime(0.0001, now+0.9); m.connect(ctx.destination);
        notes.forEach((f,i)=>{ const o = ctx.createOscillator(), g = ctx.createGain(), t0 = now + i*0.12;
          o.type='sine'; o.frequency.value=f; o.connect(g); g.connect(m);
          g.gain.setValueAtTime(0.0001, t0); g.gain.linearRampToValueAtTime(0.18, t0+0.02); g.gain.exponentialRampToValueAtTime(0.0001, t0+0.16);
          o.start(t0); o.stop(t0+0.18);
        });
      };
      const digits = {
        '0': [
          [0,1,1,1,0],
          [1,0,0,0,1],
          [1,0,0,0,1],
          [1,0,0,0,1],
          [1,0,0,0,1],
          [1,0,0,0,1],
          [0,1,1,1,0]
        ],
        '1': [
          [0,0,1,0,0],
          [0,1,1,0,0],
          [0,0,1,0,0],
          [0,0,1,0,0],
          [0,0,1,0,0],
          [0,0,1,0,0],
          [1,1,1,1,1]
        ],
        '2': [
          [1,1,1,1,1],
          [0,0,0,0,1],
          [0,0,0,1,0],
          [0,0,1,0,0],
          [0,1,0,0,0],
          [1,0,0,0,0],
          [1,1,1,1,1]
        ],
        '3': [
          [1,1,1,1,1],
          [0,0,0,0,1],
          [0,0,1,1,1],
          [0,0,0,0,1],
          [0,0,0,0,1],
          [0,0,0,0,1],
          [1,1,1,1,1]
        ],
        '4': [
          [1,0,0,0,1],
          [1,0,0,0,1],
          [1,0,0,0,1],
          [1,1,1,1,1],
          [0,0,0,0,1],
          [0,0,0,0,1],
          [0,0,0,0,1]
        ],
        '5': [
          [1,1,1,1,1],
          [1,0,0,0,0],
          [1,1,1,1,0],
          [0,0,0,0,1],
          [0,0,0,0,1],
          [1,0,0,0,1],
          [0,1,1,1,0]
        ],
        '6': [
          [0,1,1,1,0],
          [1,0,0,0,0],
          [1,0,0,0,0],
          [1,1,1,1,0],
          [1,0,0,0,1],
          [1,0,0,0,1],
          [0,1,1,1,0]
        ],
        '7': [
          [1,1,1,1,1],
          [0,0,0,0,1],
          [0,0,0,1,0],
          [0,0,1,0,0],
          [0,1,0,0,0],
          [0,1,0,0,0],
          [0,1,0,0,0]
        ],
        '8': [
          [0,1,1,1,0],
          [1,0,0,0,1],
          [1,0,0,0,1],
          [0,1,1,1,0],
          [1,0,0,0,1],
          [1,0,0,0,1],
          [0,1,1,1,0]
        ],
        '9': [
          [0,1,1,1,0],
          [1,0,0,0,1],
          [1,0,0,0,1],
          [0,1,1,1,1],
          [0,0,0,0,1],
          [0,0,0,0,1],
          [0,1,1,1,0]
        ],
        ':': [
          [0,0],
          [0,1],
          [0,0],
          [0,0],
          [0,1],
          [0,0],
          [0,0]
        ]
      };
      function drawDigit(ctx, digit, x, y) {
        const p = digits[digit]; if (!p) return; ctx.fillStyle = FONT_COLOR;
        for (let r=0;r<p.length;r++) for (let c=0;c<p[r].length;c++) if (p[r][c]) ctx.fillRect(x+c*PIXEL_SIZE,y+r*PIXEL_SIZE,PIXEL_SIZE,PIXEL_SIZE);
      }
      const formatTime = ms => {
        const s = Math.floor(ms/1000), m = Math.floor(s/60), sec = s%60, ms2 = Math.floor((ms%1000)/10);
        return `${String(m).padStart(2,'0')}:${String(sec).padStart(2,'0')}:${String(ms2).padStart(2,'0')}`;
      };
      const drawTime = str => {
        const cw=timerCanvas.clientWidth,ch=timerCanvas.clientHeight; timerCtx.clearRect(0,0,cw,ch);
        let w=0; for (const chv of str) w += (chv===':'?PIXEL_SIZE:DIGIT_WIDTH*PIXEL_SIZE)+PIXEL_SIZE; w-=PIXEL_SIZE;
        let x=(cw-w)/2,y=(ch-DIGIT_HEIGHT*PIXEL_SIZE)/2; for (const chv of str){ drawDigit(timerCtx,chv,x,y); x+= (chv===':'?PIXEL_SIZE:DIGIT_WIDTH*PIXEL_SIZE)+PIXEL_SIZE; }
      };
      const drawTree = () => {
        const cw=treeCanvas.clientWidth,ch=treeCanvas.clientHeight; treeCtx.clearRect(0,0,cw,ch);
        const cx=Math.floor(cw/2),baseY=ch,tw=Math.max(8,Math.floor(cw*0.1)),topY=baseY-treeHeight;
        const g=treeCtx.createLinearGradient(0,topY,0,baseY); g.addColorStop(0,'#8b5a2b'); g.addColorStop(1,'#5b3818'); treeCtx.fillStyle=g;
        treeCtx.beginPath(); treeCtx.moveTo(cx-tw/2,baseY); treeCtx.quadraticCurveTo(cx-tw*0.6,topY+treeHeight*0.35,cx-tw*0.18,topY); treeCtx.lineTo(cx+tw*0.18,topY); treeCtx.quadraticCurveTo(cx+tw*0.6,topY+treeHeight*0.35,cx+tw/2,baseY); treeCtx.closePath(); treeCtx.fill();
  const growth = Math.max(0,Math.min(1,treeHeight/Math.max(1,maxTreeHeight)));
  const cbaseRaw = Math.min(cw * 0.48, maxTreeHeight * 0.6);
  const crUnclamped = cbaseRaw * (0.6 + 0.9 * growth);
  const maxAllowedByWidth = Math.max(10, (cw * 0.5) - 10);
  const maxAllowedByHeight = Math.max(10, (topY - 8) > 0 ? (topY - 8) : (maxTreeHeight * 0.5));
  const cr = Math.min(crUnclamped, maxAllowedByWidth, maxAllowedByHeight);
        for (let i=0;i<7;i++){ const ang=(i/7)*Math.PI*2 + (i%2?0.3:-0.3); const sway=Math.sin(performance.now()/800+i)*(4*Math.min(1,growth)); const spread=cr*(0.35+0.25*Math.sin(i*1.3))+sway; const bx=cx+Math.cos(ang)*spread*(0.4+0.6*growth); const by=topY-Math.abs(Math.sin(ang))*cr*0.35-cr*0.15; const br=cr*(0.45+0.25*Math.cos(i*1.1))*(0.7+0.6*growth); const rg=treeCtx.createRadialGradient(bx,by,br*0.1,bx,by,br); rg.addColorStop(0,`rgba(200,255,180,${0.95*growth})`); rg.addColorStop(0.6,`rgba(90,180,80,${0.85*growth})`); rg.addColorStop(1,`rgba(30,110,40,${0.9*growth})`); treeCtx.fillStyle=rg; treeCtx.beginPath(); treeCtx.arc(bx,by,br,0,Math.PI*2); treeCtx.fill(); }
        for (let i=0;i<36;i++){ const t=i/36, a=t*Math.PI*2 + Math.sin(t*7)*0.3; const r=cr*(0.12+0.75*Math.abs(Math.cos(t*5))); const lx=cx+Math.cos(a)*r*(0.6+0.6*growth)+(Math.sin(i*3.1)*2); const ly=topY-Math.abs(Math.sin(a))*cr*0.35-(Math.cos(i*2.7)*2); const lr=Math.max(1,Math.round(1+growth*3*Math.abs(Math.sin(i*2.3)))); const s=seasonSelect?seasonSelect.value:'summer'; let col;
          if (s==='autumn'){ const R=200+Math.floor(55*Math.abs(Math.sin(i*1.9))), G=90+Math.floor(60*Math.abs(Math.cos(i*1.9))), B=30+Math.floor(20*growth); col=`rgba(${R},${G},${B},${0.95*growth})`; }
          else if (s==='spring') col=`rgba(${180+Math.floor(30*Math.abs(Math.sin(i*1.9)))},245,140,${0.95*growth})`;
          else if (s==='winter') col=`rgba(200,220,200,${0.6*growth})`;
          else { const L=190+Math.floor(60*Math.abs(Math.sin(i*2.9))); col=`rgba(${L},${230-Math.floor(40*Math.abs(Math.cos(i*1.9)))},${100+Math.floor(30*growth)},${0.95*growth})`; }
          treeCtx.fillStyle=col; treeCtx.beginPath(); treeCtx.arc(lx,ly,lr,0,Math.PI*2); treeCtx.fill(); }
        const topX=cx, topY2=topY-cr*0.15, topR=cr*0.25*(0.6+0.4*growth); const tg=treeCtx.createRadialGradient(topX,topY2,0,topX,topY2,topR); tg.addColorStop(0,`rgba(240,255,200,${0.35*growth})`); tg.addColorStop(1,'rgba(240,255,200,0)'); treeCtx.fillStyle=tg; treeCtx.beginPath(); treeCtx.arc(topX,topY2,topR,0,Math.PI*2); treeCtx.fill();
      };
      const animate = () => {
        const now = Date.now();
        const remaining = timeLeft>0?Math.max(0,timeLeft-(isRunning?(now - startTime + pausedTime):0)):0;
        if (isRunning && timeLeft > 0) {
          const elapsed = now - startTime + pausedTime;
          if (elapsed >= timeLeft) {
            isRunning = false;
            startPauseBtn.textContent = 'Start';
            input.disabled = false;
            treeHeight = maxTreeHeight;
            drawTime('00:00:00');
            drawTree();
            timeLeft = 0; pausedTime = 0;
            spawnLeaves(36);
            try{ if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); }catch(e){}
            playFinishChime();
          } else {
            const growth = Math.min(1, elapsed / (totalSeconds * 1000));
            treeHeight = Math.min(maxTreeHeight, growth * maxTreeHeight);
            drawTime(formatTime(Math.max(0, timeLeft - elapsed)));
            drawTree();
          }
        } else {
          drawTime(formatTime(remaining));
          drawTree();
        }
        if (leafFallActive) for (let i=leaves.length-1;i>=0;i--){ const L=leaves[i]; L.vy+=0.06; L.vx*=0.995; L.x+=L.vx; L.y+=L.vy; L.rot+=L.spin; treeCtx.save(); treeCtx.translate(L.x,L.y); treeCtx.rotate(L.rot); treeCtx.fillStyle=L.color; treeCtx.beginPath(); treeCtx.ellipse(0,0,L.r*1.1,L.r*0.6,0,0,Math.PI*2); treeCtx.fill(); treeCtx.restore(); if (L.y>treeCanvas.clientHeight+20||L.x<-50||L.x>treeCanvas.clientWidth+50) leaves.splice(i,1); }
        animationId=requestAnimationFrame(animate);
      };
      const spawnLeaves = (n=24)=>{ leafFallActive=true; for(let i=0;i<n;i++){ const r=6+Math.random()*6, x=treeCanvas.clientWidth/2+(Math.random()-0.5)*80, y=Math.max(0,(treeCanvas.clientHeight-treeHeight)-Math.random()*40), vx=(Math.random()-0.5)*1.6, vy=-1-Math.random()*0.5, spin=(Math.random()-0.5)*0.12, s=seasonSelect?seasonSelect.value:'summer'; let color='rgba(200,220,120,0.95)'; if(s==='autumn') color=`rgba(${210+Math.floor(Math.random()*30)},${80+Math.floor(Math.random()*50)},${30+Math.floor(Math.random()*20)},0.98)`; if(s==='spring') color='rgba(180,240,140,0.9)'; if(s==='winter') color='rgba(220,230,220,0.8)'; leaves.push({x,y,vx,vy,r,rot:Math.random()*Math.PI,spin,color}); } };
      const pauseTimer = ()=>{ if(!isRunning) return; isRunning=false; startPauseBtn.textContent='Start'; pausedTime+=Date.now()-startTime; };
      const startTimer = ()=>{
        if (isRunning) return;
        if (timeLeft <= 0) {
          const s = parseInt(input.value, 10);
          if (isNaN(s) || s <= 0) { input.value=''; input.placeholder='Please enter a number'; return; }
          totalSeconds = s; timeLeft = totalSeconds * 1000; pausedTime = 0; input.disabled = true;
        }
        isRunning = true; startPauseBtn.textContent='Pause'; startTime = Date.now();
      };
  const resetTimer = ()=>{ isRunning=false; startPauseBtn.textContent='Start'; input.disabled=false; input.value=''; input.placeholder='Time in seconds'; treeHeight=0; timeLeft=0; pausedTime=0; drawTime('00:00:00'); drawTree(); leafFallActive=false; leaves.length=0; };
      startPauseBtn.addEventListener('click', ()=> isRunning?pauseTimer():startTimer()); resetBtn.addEventListener('click', resetTimer);
      window.addEventListener('keydown', (e) => {
        if (e.code === 'Space') { e.preventDefault(); isRunning?pauseTimer():startTimer(); }
        if (e.key === 'r' || e.key === 'R') { resetTimer(); }
      });
      const musicFile = $('musicFile');
      const loadMusicBtn = $('loadMusicBtn');
      if (loadMusicBtn && musicFile) {
        loadMusicBtn.addEventListener('click', ()=> musicFile.click());
        musicFile.addEventListener('change', ()=>{
          const f = musicFile.files && musicFile.files[0];
          if (!f) return;
          try { const url = URL.createObjectURL(f); bgMusic.src = url; bgMusic.load(); musicBtn.disabled = false; musicBtn.textContent = 'Play Music'; }
          catch(e){ console.warn('Failed to load local music file', e); }
        });
      }
      if (musicBtn && bgMusic) {
        bgMusic.addEventListener('play', () => musicBtn.textContent = 'Pause Music');
        bgMusic.addEventListener('pause', () => musicBtn.textContent = 'Play Music');
        musicBtn.addEventListener('click', async () => {
          try { const c = ensureAudio(); if (c && c.state === 'suspended') await c.resume(); } catch (e) { /* ignore */ }
          if (remoteMusicAvailable && bgMusic.src) {
            if (bgMusic.paused) {
              try { const p = bgMusic.play(); if (p && typeof p.then === 'function') await p; }
              catch (err) { console.warn('bgMusic.play() failed:', err); }
            } else { bgMusic.pause(); }
          } else {
            if (!bgSynthActive) startBgSynth(); else stopBgSynth();
            musicBtn.textContent = bgSynthActive ? 'Pause Music' : 'Play Music';
          }
        });
      }
      (async function verifyRemoteMusic(){
        try {
          const srcEl = bgMusic.querySelector('source');
          const src = srcEl && srcEl.src;
          if (!src) throw new Error('no source');
          const r = await fetch(src, { method: 'GET', mode: 'cors' });
          if (!r.ok) throw new Error('status ' + r.status);
          const blob = await r.blob();
          const blobUrl = URL.createObjectURL(blob);
          bgMusic.src = blobUrl;
          bgMusic.load();
          if (loadMusicBtn) loadMusicBtn.disabled = false;
          remoteMusicAvailable = true;
        } catch (err) {
          console.warn('Remote music unavailable:', err);
          remoteMusicAvailable = false;
          if (musicBtn) { musicBtn.disabled = false; musicBtn.textContent = 'Play Music'; }
          if (loadMusicBtn) loadMusicBtn.disabled = false;
        }
      })();
      const primeAudio = ()=>{ const c=ensureAudio(); if(c&&c.state==='suspended') c.resume().catch(()=>{}); };
      [startPauseBtn,resetBtn,musicBtn,seasonSelect].forEach(el=>el&&el.addEventListener('click',primeAudio,{once:true}));
      seasonSelect&&seasonSelect.addEventListener('change',()=>drawTree());
      const resizeCanvases = ()=>{ const dpr=window.devicePixelRatio||1; const td=timerCanvas.getBoundingClientRect(), tr=treeCanvas.getBoundingClientRect(); timerCanvas.width=Math.max(200,Math.floor(td.width*dpr)); timerCanvas.height=Math.max(100,Math.floor(Math.max(td.height,td.width*0.35)*dpr)); treeCanvas.width=Math.max(100,Math.floor(tr.width*dpr)); treeCanvas.height=Math.max(100,Math.floor(Math.max(tr.height,tr.width*1.6)*dpr)); timerCtx.setTransform(dpr,0,0,dpr,0,0); treeCtx.setTransform(dpr,0,0,dpr,0,0); PIXEL_SIZE=Math.max(4,Math.floor(timerCanvas.clientWidth*0.9/(8*DIGIT_WIDTH))); maxTreeHeight=treeCanvas.clientHeight-50; drawTime(formatTime(timeLeft>0?Math.max(0,timeLeft-(isRunning?(Date.now()-startTime+pausedTime):0)):0)); drawTree(); };
      window.addEventListener('resize',resizeCanvases); timerCanvas.style.width=''; treeCanvas.style.width=''; const s=document.createElement('style'); s.textContent='#timerCanvas{flex:3;min-width:220px;} #treeCanvas{flex:1;min-width:90px;} .display-container{gap:2rem;}'; document.head.appendChild(s); treeHeight=0; drawTime('00:00:00'); if(!animationId) animationId=requestAnimationFrame(animate); setTimeout(resizeCanvases,50);
    });
  </script>
</body>
</html>
<!-- made by Maya Hazarika w/ help from Gemini and Copilot: maya.l.hazarika@gmail.com -->