<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Time Tree</title>
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link
  href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"
  rel="stylesheet"
>
<style>
:root {
  --color-bg-dark: hsl(88, 83%, 80%);
  --color-text-light: #ace67d;
  --color-green-accent: #efbac0;
  --color-green-subtle: #1e952a;
  --font-pixel: 'Press Start 2P', monospace;
}
.display-container {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
}
  body {
    background: var(--color-bg-dark);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    margin: 0;
    font-family: var(--font-pixel);
    color: var(--color-text-light);
    padding: 1rem;
    box-sizing: border-box;
  }
  h1 {
    font-size: 2rem;
    margin-bottom: 2.5rem;
  }
  .controls {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1.25rem;
    margin-bottom: 2.5rem;
  }
  input,
  button {
    font-size: 0.9rem;
    font-family: var(--font-pixel);
    background-color: var(--color-green-accent);
    color: var(--color-text-light);
    border: 2px solid var(--color-green-subtle);
    padding: 0.8rem 1.1rem;
    border-radius: 6px;
    cursor: pointer;
    text-transform: uppercase;
    transition: background-color 0.2s, border-color 0.2s;
    outline: none;
  }
  input {
    text-align: center;
    max-width: 150px;
    background-color: transparent;
  }
  input::placeholder {
    color: var(--color-green-subtle);
    opacity: 0.8;
  }
  input:focus,
  button:hover,
  button:focus {
    background-color: var(--color-green-subtle);
    border-color: var(--color-text-light);
    color: var(--color-bg-dark);
  }
  button:disabled {
    cursor: not-allowed;
    opacity: 0.6;
  }
  canvas {
    image-rendering: pixelated;
    background: var(--color-green-accent);
    margin-top: 1rem;
    border: 2px solid var(--color-green-subtle);
    /* shadows removed per request */
    box-shadow: none;
    max-width: 100%;
    height: auto;
  }
  .display-container {
    width: 100%;
    max-width: 900px;
    padding: 1rem;
    box-sizing: border-box;
  }
  @media (max-width: 600px) {
    .display-container {
      flex-direction: column;
      gap: 1.75rem;
    }
  }
</style>
</head>
<body>
  <h1>Time Tree</h1>
  <div class="display-container">
  <canvas id="timerCanvas" width="300" height="200"></canvas>
  <canvas id="treeCanvas" width="100" height="200"></canvas>
</div>
  <div class="controls">
    <input
      id="inputSeconds"
      type="number"
      min="1"
      placeholder="Time in seconds"
      aria-label="Enter time in seconds"
    />
    <div>
      <button id="startPauseBtn" aria-label="Start or Pause Timer">Start</button>
      <button id="resetBtn" aria-label="Reset Timer">Reset</button>
      <button id="musicBtn" aria-label="Toggle background music">Play Music</button>
    </div>
  </div>
  <audio id="bgMusic" loop crossorigin="anonymous" preload="auto">
    <source src="https://cdn.pixabay.com/download/audio/2022/03/03/audio_2d59e2f48f.mp3?filename=relaxing-music-ambient-3781.mp3" type="audio/mpeg" />
  </audio>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
  const startPauseBtn = document.getElementById('startPauseBtn');
  const resetBtn = document.getElementById('resetBtn');
  const input = document.getElementById('inputSeconds');
    const musicBtn = document.getElementById('musicBtn');
    const bgMusic = document.getElementById('bgMusic');
      const timerCanvas = document.getElementById('timerCanvas');
      const timerCtx = timerCanvas.getContext('2d');
      const treeCanvas = document.getElementById('treeCanvas');
      const treeCtx = treeCanvas.getContext('2d');
      let PIXEL_SIZE = 12;
      const FONT_COLOR = '#e0f8cf';
      const DIGIT_WIDTH = 5;
      const DIGIT_HEIGHT = 7;
      let countdownInterval;
      let isRunning = false;
      let timeLeft = 0;
      let totalSeconds = 0;
      let maxTreeHeight = 0;
      let treeHeight = 0;
      let pausedTime = 0;
      let startTime = 0;
      const digits = {
        '0': [
          [0,1,1,1,0],
          [1,0,0,0,1],
          [1,0,0,0,1],
          [1,0,0,0,1],
          [1,0,0,0,1],
          [1,0,0,0,1],
          [0,1,1,1,0]
        ],
        '1': [
          [0,0,1,0,0],
          [0,1,1,0,0],
          [0,0,1,0,0],
          [0,0,1,0,0],
          [0,0,1,0,0],
          [0,0,1,0,0],
          [1,1,1,1,1]
        ],
        '2': [
          [1,1,1,1,1],
          [0,0,0,0,1],
          [0,0,0,1,0],
          [0,0,1,0,0],
          [0,1,0,0,0],
          [1,0,0,0,0],
          [1,1,1,1,1]
        ],
        '3': [
          [1,1,1,1,1],
          [0,0,0,0,1],
          [0,0,1,1,1],
          [0,0,0,0,1],
          [0,0,0,0,1],
          [0,0,0,0,1],
          [1,1,1,1,1]
        ],
        '4': [
          [1,0,0,0,1],
          [1,0,0,0,1],
          [1,0,0,0,1],
          [1,1,1,1,1],
          [0,0,0,0,1],
          [0,0,0,0,1],
          [0,0,0,0,1]
        ],
        '5': [
          [1,1,1,1,1],
          [1,0,0,0,0],
          [1,1,1,1,0],
          [0,0,0,0,1],
          [0,0,0,0,1],
          [1,0,0,0,1],
          [0,1,1,1,0]
        ],
        '6': [
          [0,1,1,1,0],
          [1,0,0,0,0],
          [1,0,0,0,0],
          [1,1,1,1,0],
          [1,0,0,0,1],
          [1,0,0,0,1],
          [0,1,1,1,0]
        ],
        '7': [
          [1,1,1,1,1],
          [0,0,0,0,1],
          [0,0,0,1,0],
          [0,0,1,0,0],
          [0,1,0,0,0],
          [0,1,0,0,0],
          [0,1,0,0,0]
        ],
        '8': [
          [0,1,1,1,0],
          [1,0,0,0,1],
          [1,0,0,0,1],
          [0,1,1,1,0],
          [1,0,0,0,1],
          [1,0,0,0,1],
          [0,1,1,1,0]
        ],
        '9': [
          [0,1,1,1,0],
          [1,0,0,0,1],
          [1,0,0,0,1],
          [0,1,1,1,1],
          [0,0,0,0,1],
          [0,0,0,0,1],
          [0,1,1,1,0]
        ],
        ':': [
          [0,0],
          [0,1],
          [0,0],
          [0,0],
          [0,1],
          [0,0],
          [0,0]
        ]
      };
      function drawDigit(ctx, digit, x, y) {
        const pattern = digits[digit];
        if (!pattern) return;
        ctx.fillStyle = FONT_COLOR;
        for (let row = 0; row < pattern.length; row++) {
          for (let col = 0; col < pattern[row].length; col++) {
            if (pattern[row][col] === 1) {
              ctx.fillRect(
                x + col * PIXEL_SIZE,
                y + row * PIXEL_SIZE,
                PIXEL_SIZE,
                PIXEL_SIZE
              );
            }
          }
        }
      }
function formatTime(ms) {
    const totalSeconds = Math.floor(ms / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    const milliseconds = Math.floor((ms % 1000) / 10);

    const mStr = String(minutes).padStart(2, '0');
    const sStr = String(seconds).padStart(2, '0');
    const msStr = String(milliseconds).padStart(2, '0');
    
    return `${mStr}:${sStr}:${msStr}`;
}
      function drawTime(timeString) {
        const cw = timerCanvas.clientWidth;
        const ch = timerCanvas.clientHeight;
        timerCtx.clearRect(0, 0, cw, ch);
        let totalWidth = 0;
        for (const char of timeString) {
          totalWidth += (char === ':' ? PIXEL_SIZE : DIGIT_WIDTH * PIXEL_SIZE) + PIXEL_SIZE;
        }
        totalWidth -= PIXEL_SIZE;
        let startX = (cw - totalWidth) / 2;
        const startY = (ch - DIGIT_HEIGHT * PIXEL_SIZE) / 2;
        for (const char of timeString) {
          drawDigit(timerCtx, char, startX, startY);
          startX += (char === ':' ? PIXEL_SIZE : DIGIT_WIDTH * PIXEL_SIZE) + PIXEL_SIZE;
        }
      }
      function drawTree() {
        const cw = treeCanvas.clientWidth;
        const ch = treeCanvas.clientHeight;
        treeCtx.clearRect(0, 0, cw, ch);

        // base coordinates
        const centerX = Math.floor(cw / 2);
        const baseY = ch;

        // trunk geometry scales with canvas width
        const trunkW = Math.max(8, Math.floor(cw * 0.10));
        const trunkTopY = baseY - treeHeight;

        // draw tapered trunk using a path and a vertical gradient
        const trunkGradient = treeCtx.createLinearGradient(0, trunkTopY, 0, baseY);
        trunkGradient.addColorStop(0, '#8b5a2b');
        trunkGradient.addColorStop(1, '#5b3818');

        treeCtx.fillStyle = trunkGradient;
        treeCtx.beginPath();
        // left edge
        treeCtx.moveTo(centerX - trunkW / 2, baseY);
        treeCtx.quadraticCurveTo(centerX - trunkW * 0.6, trunkTopY + treeHeight * 0.35, centerX - trunkW * 0.18, trunkTopY);
        // right edge
        treeCtx.lineTo(centerX + trunkW * 0.18, trunkTopY);
        treeCtx.quadraticCurveTo(centerX + trunkW * 0.6, trunkTopY + treeHeight * 0.35, centerX + trunkW / 2, baseY);
        treeCtx.closePath();
        treeCtx.fill();

        // canopy sizing (bigger when treeHeight grows)
        const growthRatio = Math.max(0, Math.min(1, treeHeight / Math.max(1, maxTreeHeight)));
        const canopyBaseRadius = Math.min(cw * 0.48, maxTreeHeight * 0.6);
        const canopyRadius = canopyBaseRadius * (0.6 + 0.9 * growthRatio);

        // layered canopy: several overlapping blobs with radial gradients
        const blobs = 7; // number of canopy blobs
        for (let i = 0; i < blobs; i++) {
          const angle = (i / blobs) * Math.PI * 2 + (i % 2 === 0 ? -0.3 : 0.3);
          const spread = canopyRadius * (0.35 + 0.25 * Math.sin(i * 1.3));
          const bx = centerX + Math.cos(angle) * spread * (0.4 + 0.6 * growthRatio);
          const by = trunkTopY - Math.abs(Math.sin(angle)) * canopyRadius * 0.35 - canopyRadius * 0.15;
          const br = canopyRadius * (0.45 + 0.25 * Math.cos(i * 1.1)) * (0.7 + 0.6 * growthRatio);

          const g = treeCtx.createRadialGradient(bx, by, br * 0.1, bx, by, br);
          g.addColorStop(0, `rgba(200,255,180,${0.95 * growthRatio})`);
          g.addColorStop(0.6, `rgba(90,180,80,${0.85 * growthRatio})`);
          g.addColorStop(1, `rgba(30,110,40,${0.9 * growthRatio})`);

          treeCtx.fillStyle = g;
          treeCtx.beginPath();
          treeCtx.arc(bx, by, br, 0, Math.PI * 2);
          treeCtx.fill();
        }

        // leaf speckles (deterministic pattern so redraws look stable)
        const speckles = 36;
        for (let i = 0; i < speckles; i++) {
          const t = i / speckles;
          // deterministic polar coords
          const a = t * Math.PI * 2 + (Math.sin(t * 7) * 0.3);
          const r = canopyRadius * (0.12 + 0.75 * Math.abs(Math.cos(t * 5)));
          const lx = centerX + Math.cos(a) * r * (0.6 + 0.6 * growthRatio) + (Math.sin(i * 3.1) * 2);
          const ly = trunkTopY - Math.abs(Math.sin(a)) * canopyRadius * 0.35 - (Math.cos(i * 2.7) * 2);
          const lr = Math.max(1, Math.round(1 + growthRatio * 3 * (Math.abs(Math.sin(i * 2.3)))));

          // color variation
          const light = 190 + Math.floor(60 * Math.abs(Math.sin(i * 2.9)));
          treeCtx.fillStyle = `rgba(${light},${230 - Math.floor(40 * Math.abs(Math.cos(i * 1.9)))},${100 + Math.floor(30 * growthRatio)},${0.95 * growthRatio})`;
          treeCtx.beginPath();
          treeCtx.arc(lx, ly, lr, 0, Math.PI * 2);
          treeCtx.fill();
        }

        // highlight at canopy top
        const topX = centerX;
        const topY = trunkTopY - canopyRadius * 0.15;
        const topR = canopyRadius * 0.25 * (0.6 + 0.4 * growthRatio);
        const topG = treeCtx.createRadialGradient(topX, topY, 0, topX, topY, topR);
        topG.addColorStop(0, `rgba(240,255,200,${0.35 * growthRatio})`);
        topG.addColorStop(1, `rgba(240,255,200,0)`);
        treeCtx.fillStyle = topG;
        treeCtx.beginPath();
        treeCtx.arc(topX, topY, topR, 0, Math.PI * 2);
        treeCtx.fill();
      }
      function pauseTimer() {
        if (!isRunning) return;
        isRunning = false; // This flag stops the requestAnimationFrame loop
        startPauseBtn.textContent = 'Start';
        pausedTime += Date.now() - startTime;
      }
      function startTimer() {
        if (isRunning) return;
        if (timeLeft <= 0) {
          let secondsInput = parseInt(input.value, 10);
          if (isNaN(secondsInput) || secondsInput <= 0) {
            input.value = '';
            input.placeholder = 'Please enter a number';
            return;
          }
          totalSeconds = secondsInput;
          timeLeft = totalSeconds * 1000;
          pausedTime = 0;
          input.disabled = true;
        }
        isRunning = true;
        startPauseBtn.textContent = 'Pause';
        startTime = Date.now();
        countdownInterval = setInterval(() => {
          const elapsedTime = Date.now() - startTime + pausedTime;
          const remainingTime = timeLeft - elapsedTime;
          if (remainingTime <= 0) {
            clearInterval(countdownInterval);
            isRunning = false;
            startPauseBtn.textContent = 'Start';
            input.disabled = false;
            treeHeight = maxTreeHeight;
            drawTime('00:00:00');
            drawTree();
            timeLeft = 0;
            pausedTime = 0;
            try { bgMusic.pause(); } catch (e) {}
            if (musicBtn) musicBtn.textContent = 'Play Music';
            return;
          }
          const growthRatio = Math.min(1, elapsedTime / (totalSeconds * 1000));
          treeHeight = growthRatio * maxTreeHeight;
          drawTime(formatTime(remainingTime));
          drawTree();
        }, 50);
      }
      function resetTimer() {
        clearInterval(countdownInterval);
        isRunning = false;
        startPauseBtn.textContent = 'Start';
        input.disabled = false;
        input.value = '';
        input.placeholder = 'Time in seconds';
        treeHeight = 0;
        timeLeft = 0;
        pausedTime = 0;
        drawTime('00:00:00');
        drawTree();
      }
      startPauseBtn.addEventListener('click', () => {
        if (isRunning) {
          pauseTimer();
        } else {
          startTimer();
        }
      });
      resetBtn.addEventListener('click', resetTimer);
        // music controls
        if (musicBtn && bgMusic) {
          musicBtn.addEventListener('click', () => {
            if (bgMusic.paused) {
              const p = bgMusic.play();
              if (p && typeof p.then === 'function') {
                p.then(() => { musicBtn.textContent = 'Pause Music'; })
                 .catch(err => { console.warn('Music play blocked', err); musicBtn.textContent = 'Play Music'; });
              } else {
                musicBtn.textContent = 'Pause Music';
              }
            } else {
              bgMusic.pause();
              musicBtn.textContent = 'Play Music';
            }
          });
        }
function resizeCanvases() {
    const dpr = window.devicePixelRatio || 1;
    const timerDisplay = timerCanvas.getBoundingClientRect();
    const treeDisplay = treeCanvas.getBoundingClientRect();
    timerCanvas.width = Math.max(200, Math.floor(timerDisplay.width * dpr));
    timerCanvas.height = Math.max(100, Math.floor(Math.max(timerDisplay.height, timerDisplay.width * 0.35) * dpr));
    treeCanvas.width = Math.max(100, Math.floor(treeDisplay.width * dpr));
    treeCanvas.height = Math.max(100, Math.floor(Math.max(treeDisplay.height, treeDisplay.width * 1.6) * dpr));
    timerCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
    treeCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
    const desiredWidth = timerCanvas.clientWidth * 0.9;
    const charCount = 8; // M:SS:ms is 8 characters
    PIXEL_SIZE = Math.max(4, Math.floor(desiredWidth / (charCount * DIGIT_WIDTH)));
    maxTreeHeight = treeCanvas.clientHeight - 50;
    const currentRemaining = timeLeft > 0 ? Math.max(0, timeLeft - (isRunning ? (Date.now() - startTime + pausedTime) : 0)) : 0;
    drawTime(formatTime(currentRemaining));
    drawTree();
}      
    window.addEventListener('resize', resizeCanvases);
      timerCanvas.style.width = '';
      treeCanvas.style.width = '';
      const style = document.createElement('style');
      style.textContent = '#timerCanvas{flex:3;min-width:220px;} #treeCanvas{flex:1;min-width:90px;} .display-container{gap:2rem;}';
      document.head.appendChild(style);
      treeHeight = 0;
      drawTime('00:00:00');
      setTimeout(resizeCanvases, 50);
    });
  </script>
</body>
</html>

\\ made by Maya Hazarika w/ help from Gemini and Copilot: maya.l.hazarika@gmail.com \\