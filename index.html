<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Time Tree</title>
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link
  href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"
  rel="stylesheet"
>
<style>
:root {
  --color-bg-dark: hsl(88, 83%, 80%);
  --color-text-light: #ace67d;
  --color-green-accent: #efbac0;
  --color-green-subtle: #1e952a;
  --font-pixel: 'Press Start 2P', monospace;
}
.display-container {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
}
  body {
    background: var(--color-bg-dark);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    margin: 0;
    font-family: var(--font-pixel);
    color: var(--color-text-light);
    padding: 1rem;
    box-sizing: border-box;
  }
  h1 {
    font-size: 2rem;
    margin-bottom: 2.5rem;
  }
  .controls {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1.25rem;
    margin-bottom: 2.5rem;
  }
  input,
  button {
    font-size: 0.9rem;
    font-family: var(--font-pixel);
    background-color: var(--color-green-accent);
    color: var(--color-text-light);
    border: 2px solid var(--color-green-subtle);
    padding: 0.8rem 1.1rem;
    border-radius: 6px;
    cursor: pointer;
    text-transform: uppercase;
    transition: background-color 0.2s, border-color 0.2s;
    outline: none;
  }
  input {
    text-align: center;
    max-width: 150px;
    background-color: transparent;
  }
  input::placeholder {
    color: var(--color-green-subtle);
    opacity: 0.8;
  }
  input:focus,
  button:hover,
  button:focus {
    background-color: var(--color-green-subtle);
    border-color: var(--color-text-light);
    color: var(--color-bg-dark);
  }
  select {
    font-family: var(--font-pixel);
    background-color: var(--color-green-accent);
    color: var(--color-text-light);
    border: 2px solid var(--color-green-subtle);
    padding: 0.4rem 0.6rem;
    border-radius: 6px;
    outline: none;
  }
  button:disabled {
    cursor: not-allowed;
    opacity: 0.6;
  }
  canvas {
    image-rendering: pixelated;
    background: var(--color-green-accent);
    margin-top: 1rem;
    border: 2px solid var(--color-green-subtle);
    /* shadows removed per request */
    box-shadow: none;
    max-width: 100%;
    height: auto;
  }
  .display-container {
    width: 100%;
    max-width: 900px;
    padding: 1rem;
    box-sizing: border-box;
  }
  @media (max-width: 600px) {
    .display-container {
      flex-direction: column;
      gap: 1.75rem;
    }
  }
</style>
</head>
<body>
  <h1>Time Tree</h1>
  <div class="display-container">
  <canvas id="timerCanvas" width="300" height="200"></canvas>
  <canvas id="treeCanvas" width="100" height="200"></canvas>
</div>
  <div class="controls">
    <input
      id="inputSeconds"
      type="number"
      min="1"
      placeholder="Time in seconds"
      aria-label="Enter time in seconds"
    />
    <div>
      <button id="startPauseBtn" aria-label="Start or Pause Timer">Start</button>
      <button id="resetBtn" aria-label="Reset Timer">Reset</button>
      <button id="musicBtn" aria-label="Toggle background music">Play Music</button>
    </div>
    <div style="margin-top:0.6rem;display:flex;gap:0.6rem;align-items:center;">
      <label for="seasonSelect" style="font-size:0.7rem;opacity:0.9;margin:0;">Season</label>
      <select id="seasonSelect" aria-label="Season">
        <option value="spring">Spring</option>
        <option value="summer" selected>Summer</option>
        <option value="autumn">Autumn</option>
        <option value="winter">Winter</option>
      </select>
    </div>
  </div>
  <audio id="bgMusic" loop crossorigin="anonymous" preload="auto">
    <source src="https://cdn.pixabay.com/download/audio/2022/03/03/audio_2d59e2f48f.mp3?filename=relaxing-music-ambient-3781.mp3" type="audio/mpeg" />
  </audio>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
  const startPauseBtn = document.getElementById('startPauseBtn');
  const resetBtn = document.getElementById('resetBtn');
  const input = document.getElementById('inputSeconds');
    const musicBtn = document.getElementById('musicBtn');
    const bgMusic = document.getElementById('bgMusic');
      const timerCanvas = document.getElementById('timerCanvas');
      const timerCtx = timerCanvas.getContext('2d');
      const treeCanvas = document.getElementById('treeCanvas');
      const treeCtx = treeCanvas.getContext('2d');
  const seasonSelect = document.getElementById('seasonSelect');
      let PIXEL_SIZE = 12;
      const FONT_COLOR = '#e0f8cf';
      const DIGIT_WIDTH = 5;
      const DIGIT_HEIGHT = 7;
      let countdownInterval;
      let isRunning = false;
      let timeLeft = 0;
      let totalSeconds = 0;
      let maxTreeHeight = 0;
      let treeHeight = 0;
      let pausedTime = 0;
      let startTime = 0;
  let animationId = null;
  const leaves = [];
  let leafFallActive = false;
      let audioCtx = null;
      function ensureAudioContext() {
        if (!audioCtx) {
          try {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          } catch (e) {
            console.warn('WebAudio not supported:', e);
            audioCtx = null;
          }
        }
        return audioCtx;
      }
      function playFinishChime() {
        const ctx = ensureAudioContext();
        if (!ctx) return;
        const notes = [880, 1100, 1320];
        const now = ctx.currentTime;
        const master = ctx.createGain();
        master.gain.value = 0.001;
        master.connect(ctx.destination);
        master.gain.setValueAtTime(0.001, now);
        master.gain.linearRampToValueAtTime(0.12, now + 0.02);
        master.gain.linearRampToValueAtTime(0.0001, now + 0.9);

        notes.forEach((freq, i) => {
          const o = ctx.createOscillator();
          o.type = 'sine';
          o.frequency.value = freq;
          const env = ctx.createGain();
          env.gain.value = 0.0001;
          o.connect(env);
          env.connect(master);
          const t0 = now + i * 0.12;
          o.start(t0);
          env.gain.setValueAtTime(0.0001, t0);
          env.gain.linearRampToValueAtTime(0.18, t0 + 0.02);
          env.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.16);
          o.stop(t0 + 0.18);
        });
      }
      const digits = {
        '0': [
          [0,1,1,1,0],
          [1,0,0,0,1],
          [1,0,0,0,1],
          [1,0,0,0,1],
          [1,0,0,0,1],
          [1,0,0,0,1],
          [0,1,1,1,0]
        ],
        '1': [
          [0,0,1,0,0],
          [0,1,1,0,0],
          [0,0,1,0,0],
          [0,0,1,0,0],
          [0,0,1,0,0],
          [0,0,1,0,0],
          [1,1,1,1,1]
        ],
        '2': [
          [1,1,1,1,1],
          [0,0,0,0,1],
          [0,0,0,1,0],
          [0,0,1,0,0],
          [0,1,0,0,0],
          [1,0,0,0,0],
          [1,1,1,1,1]
        ],
        '3': [
          [1,1,1,1,1],
          [0,0,0,0,1],
          [0,0,1,1,1],
          [0,0,0,0,1],
          [0,0,0,0,1],
          [0,0,0,0,1],
          [1,1,1,1,1]
        ],
        '4': [
          [1,0,0,0,1],
          [1,0,0,0,1],
          [1,0,0,0,1],
          [1,1,1,1,1],
          [0,0,0,0,1],
          [0,0,0,0,1],
          [0,0,0,0,1]
        ],
        '5': [
          [1,1,1,1,1],
          [1,0,0,0,0],
          [1,1,1,1,0],
          [0,0,0,0,1],
          [0,0,0,0,1],
          [1,0,0,0,1],
          [0,1,1,1,0]
        ],
        '6': [
          [0,1,1,1,0],
          [1,0,0,0,0],
          [1,0,0,0,0],
          [1,1,1,1,0],
          [1,0,0,0,1],
          [1,0,0,0,1],
          [0,1,1,1,0]
        ],
        '7': [
          [1,1,1,1,1],
          [0,0,0,0,1],
          [0,0,0,1,0],
          [0,0,1,0,0],
          [0,1,0,0,0],
          [0,1,0,0,0],
          [0,1,0,0,0]
        ],
        '8': [
          [0,1,1,1,0],
          [1,0,0,0,1],
          [1,0,0,0,1],
          [0,1,1,1,0],
          [1,0,0,0,1],
          [1,0,0,0,1],
          [0,1,1,1,0]
        ],
        '9': [
          [0,1,1,1,0],
          [1,0,0,0,1],
          [1,0,0,0,1],
          [0,1,1,1,1],
          [0,0,0,0,1],
          [0,0,0,0,1],
          [0,1,1,1,0]
        ],
        ':': [
          [0,0],
          [0,1],
          [0,0],
          [0,0],
          [0,1],
          [0,0],
          [0,0]
        ]
      };
      function drawDigit(ctx, digit, x, y) {
        const pattern = digits[digit];
        if (!pattern) return;
        ctx.fillStyle = FONT_COLOR;
        for (let row = 0; row < pattern.length; row++) {
          for (let col = 0; col < pattern[row].length; col++) {
            if (pattern[row][col] === 1) {
              ctx.fillRect(
                x + col * PIXEL_SIZE,
                y + row * PIXEL_SIZE,
                PIXEL_SIZE,
                PIXEL_SIZE
              );
            }
          }
        }
      }
function formatTime(ms) {
    const totalSeconds = Math.floor(ms / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    const milliseconds = Math.floor((ms % 1000) / 10);

    const mStr = String(minutes).padStart(2, '0');
    const sStr = String(seconds).padStart(2, '0');
    const msStr = String(milliseconds).padStart(2, '0');
    
    return `${mStr}:${sStr}:${msStr}`;
}
      function drawTime(timeString) {
        const cw = timerCanvas.clientWidth;
        const ch = timerCanvas.clientHeight;
        timerCtx.clearRect(0, 0, cw, ch);
        let totalWidth = 0;
        for (const char of timeString) {
          totalWidth += (char === ':' ? PIXEL_SIZE : DIGIT_WIDTH * PIXEL_SIZE) + PIXEL_SIZE;
        }
        totalWidth -= PIXEL_SIZE;
        let startX = (cw - totalWidth) / 2;
        const startY = (ch - DIGIT_HEIGHT * PIXEL_SIZE) / 2;
        for (const char of timeString) {
          drawDigit(timerCtx, char, startX, startY);
          startX += (char === ':' ? PIXEL_SIZE : DIGIT_WIDTH * PIXEL_SIZE) + PIXEL_SIZE;
        }
      }
      function drawTree() {
        const cw = treeCanvas.clientWidth;
        const ch = treeCanvas.clientHeight;
        treeCtx.clearRect(0, 0, cw, ch);
        const centerX = Math.floor(cw / 2);
        const baseY = ch;
        const trunkW = Math.max(8, Math.floor(cw * 0.10));
        const trunkTopY = baseY - treeHeight;
        const trunkGradient = treeCtx.createLinearGradient(0, trunkTopY, 0, baseY);
        trunkGradient.addColorStop(0, '#8b5a2b');
        trunkGradient.addColorStop(1, '#5b3818');
        treeCtx.fillStyle = trunkGradient;
        treeCtx.beginPath();
        treeCtx.moveTo(centerX - trunkW / 2, baseY);
        treeCtx.quadraticCurveTo(centerX - trunkW * 0.6, trunkTopY + treeHeight * 0.35, centerX - trunkW * 0.18, trunkTopY);
        treeCtx.lineTo(centerX + trunkW * 0.18, trunkTopY);
        treeCtx.quadraticCurveTo(centerX + trunkW * 0.6, trunkTopY + treeHeight * 0.35, centerX + trunkW / 2, baseY);
        treeCtx.closePath();
        treeCtx.fill();
        const growthRatio = Math.max(0, Math.min(1, treeHeight / Math.max(1, maxTreeHeight)));
        const canopyBaseRadius = Math.min(cw * 0.48, maxTreeHeight * 0.6);
        const canopyRadius = canopyBaseRadius * (0.6 + 0.9 * growthRatio);
        const blobs = 7;
        for (let i = 0; i < blobs; i++) {
          const angle = (i / blobs) * Math.PI * 2 + (i % 2 === 0 ? -0.3 : 0.3);
          const sway = Math.sin(performance.now() / 800 + i) * (4 * Math.min(1, growthRatio));
          const spread = canopyRadius * (0.35 + 0.25 * Math.sin(i * 1.3)) + sway;
          const bx = centerX + Math.cos(angle) * spread * (0.4 + 0.6 * growthRatio);
          const by = trunkTopY - Math.abs(Math.sin(angle)) * canopyRadius * 0.35 - canopyRadius * 0.15;
          const br = canopyRadius * (0.45 + 0.25 * Math.cos(i * 1.1)) * (0.7 + 0.6 * growthRatio);
          const g = treeCtx.createRadialGradient(bx, by, br * 0.1, bx, by, br);
          g.addColorStop(0, `rgba(200,255,180,${0.95 * growthRatio})`);
          g.addColorStop(0.6, `rgba(90,180,80,${0.85 * growthRatio})`);
          g.addColorStop(1, `rgba(30,110,40,${0.9 * growthRatio})`);
          treeCtx.fillStyle = g;
          treeCtx.beginPath();
          treeCtx.arc(bx, by, br, 0, Math.PI * 2);
          treeCtx.fill();
        }
        const speckles = 36;
        for (let i = 0; i < speckles; i++) {
          const t = i / speckles;
          const a = t * Math.PI * 2 + (Math.sin(t * 7) * 0.3);
          const r = canopyRadius * (0.12 + 0.75 * Math.abs(Math.cos(t * 5)));
          const lx = centerX + Math.cos(a) * r * (0.6 + 0.6 * growthRatio) + (Math.sin(i * 3.1) * 2);
          const ly = trunkTopY - Math.abs(Math.sin(a)) * canopyRadius * 0.35 - (Math.cos(i * 2.7) * 2);
          const lr = Math.max(1, Math.round(1 + growthRatio * 3 * (Math.abs(Math.sin(i * 2.3)))));
          const season = seasonSelect ? seasonSelect.value : 'summer';
          let fillColor;
          if (season === 'autumn') {
            const r = 200 + Math.floor(55 * Math.abs(Math.sin(i * 1.9)));
            const g = 90 + Math.floor(60 * Math.abs(Math.cos(i * 1.9)));
            const b = 30 + Math.floor(20 * growthRatio);
            fillColor = `rgba(${r},${g},${b},${0.95 * growthRatio})`;
          } else if (season === 'spring') {
            fillColor = `rgba(${180 + Math.floor(30 * Math.abs(Math.sin(i * 1.9)))},${245},${140},${0.95 * growthRatio})`;
          } else if (season === 'winter') {
            fillColor = `rgba(${200},${220},${200},${0.6 * growthRatio})`;
          } else {
            const light = 190 + Math.floor(60 * Math.abs(Math.sin(i * 2.9)));
            fillColor = `rgba(${light},${230 - Math.floor(40 * Math.abs(Math.cos(i * 1.9)))},${100 + Math.floor(30 * growthRatio)},${0.95 * growthRatio})`;
          }
          treeCtx.fillStyle = fillColor;
          treeCtx.beginPath();
          treeCtx.arc(lx, ly, lr, 0, Math.PI * 2);
          treeCtx.fill();
        }
        const topX = centerX;
        const topY = trunkTopY - canopyRadius * 0.15;
        const topR = canopyRadius * 0.25 * (0.6 + 0.4 * growthRatio);
        const topG = treeCtx.createRadialGradient(topX, topY, 0, topX, topY, topR);
        topG.addColorStop(0, `rgba(240,255,200,${0.35 * growthRatio})`);
        topG.addColorStop(1, `rgba(240,255,200,0)`);
        treeCtx.fillStyle = topG;
        treeCtx.beginPath();
        treeCtx.arc(topX, topY, topR, 0, Math.PI * 2);
        treeCtx.fill();
      }
      function animate() {
        drawTime(formatTime(timeLeft > 0 ? Math.max(0, timeLeft - (isRunning ? (Date.now() - startTime + pausedTime) : 0)) : 0));
        drawTree();
        if (leafFallActive) {
          for (let i = leaves.length - 1; i >= 0; i--) {
            const leaf = leaves[i];
            leaf.vy += 0.06;
            leaf.vx *= 0.995;
            leaf.x += leaf.vx;
            leaf.y += leaf.vy;
            leaf.rot += leaf.spin;
            treeCtx.save();
            treeCtx.translate(leaf.x, leaf.y);
            treeCtx.rotate(leaf.rot);
            treeCtx.fillStyle = leaf.color;
            treeCtx.beginPath();
            treeCtx.ellipse(0, 0, leaf.r * 1.1, leaf.r * 0.6, 0, 0, Math.PI * 2);
            treeCtx.fill();
            treeCtx.restore();
            if (leaf.y > treeCanvas.clientHeight + 20 || leaf.x < -50 || leaf.x > treeCanvas.clientWidth + 50) {
              leaves.splice(i, 1);
            }
          }
        }
        animationId = requestAnimationFrame(animate);
      }
      function spawnLeaves(count = 24) {
        leafFallActive = true;
        for (let i = 0; i < count; i++) {
          const angle = Math.random() * Math.PI * 2;
          const r = 6 + Math.random() * 6;
          const x = treeCanvas.clientWidth / 2 + (Math.random() - 0.5) * 80;
          const y = Math.max(0, (treeCanvas.clientHeight - treeHeight) - Math.random() * 40);
          const vx = (Math.random() - 0.5) * 1.6;
          const vy = -1 - Math.random() * 0.5;
          const spin = (Math.random() - 0.5) * 0.12;
          const season = seasonSelect ? seasonSelect.value : 'summer';
          let color = 'rgba(200,220,120,0.95)';
          if (season === 'autumn') color = `rgba(${210 + Math.floor(Math.random()*30)},${80 + Math.floor(Math.random()*50)},${30 + Math.floor(Math.random()*20)},0.98)`;
          if (season === 'spring') color = `rgba(180,240,140,0.9)`;
          if (season === 'winter') color = `rgba(220,230,220,0.8)`;
          leaves.push({ x, y, vx, vy, r, rot: Math.random() * Math.PI, spin, color });
        }
      }
      function pauseTimer() {
        if (!isRunning) return;
        isRunning = false;
        startPauseBtn.textContent = 'Start';
        pausedTime += Date.now() - startTime;
      }
      function startTimer() {
        if (isRunning) return;
        if (timeLeft <= 0) {
          let secondsInput = parseInt(input.value, 10);
          if (isNaN(secondsInput) || secondsInput <= 0) {
            input.value = '';
            input.placeholder = 'Please enter a number';
            return;
          }
          totalSeconds = secondsInput;
          timeLeft = totalSeconds * 1000;
          pausedTime = 0;
          input.disabled = true;
        }
        isRunning = true;
        startPauseBtn.textContent = 'Pause';
        startTime = Date.now();
        countdownInterval = setInterval(() => {
          const elapsedTime = Date.now() - startTime + pausedTime;
          const remainingTime = timeLeft - elapsedTime;
          if (remainingTime <= 0) {
            clearInterval(countdownInterval);
            isRunning = false;
            startPauseBtn.textContent = 'Start';
            input.disabled = false;
            treeHeight = maxTreeHeight;
            drawTime('00:00:00');
            drawTree();
            timeLeft = 0;
            pausedTime = 0;
            spawnLeaves(36);
            try { if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); } catch(e){}
            playFinishChime();
            return;
          }
          const growthRatio = Math.min(1, elapsedTime / (totalSeconds * 1000));
          treeHeight = growthRatio * maxTreeHeight;
          drawTime(formatTime(remainingTime));
          drawTree();
        }, 50);
      }
      function resetTimer() {
        clearInterval(countdownInterval);
        isRunning = false;
        startPauseBtn.textContent = 'Start';
        input.disabled = false;
        input.value = '';
        input.placeholder = 'Time in seconds';
        treeHeight = 0;
        timeLeft = 0;
        pausedTime = 0;
        drawTime('00:00:00');
        drawTree();
        leafFallActive = false;
        leaves.length = 0;
      }
      startPauseBtn.addEventListener('click', () => {
        if (isRunning) {
          pauseTimer();
        } else {
          startTimer();
        }
      });
      resetBtn.addEventListener('click', resetTimer);
        if (musicBtn && bgMusic) {
          musicBtn.addEventListener('click', () => {
            if (bgMusic.paused) {
              const p = bgMusic.play();
              if (p && typeof p.then === 'function') {
                p.then(() => { musicBtn.textContent = 'Pause Music'; })
                 .catch(err => { console.warn('Music play blocked', err); musicBtn.textContent = 'Play Music'; });
              } else {
                musicBtn.textContent = 'Pause Music';
              }
              function primeAudio() {
                const ctx = ensureAudioContext();
                if (ctx && ctx.state === 'suspended') ctx.resume().catch(()=>{});
              }
              [startPauseBtn, resetBtn, musicBtn, seasonSelect].forEach(el => {
                if (el) el.addEventListener('click', primeAudio, { once: true });
              });
              if (seasonSelect) {
                seasonSelect.addEventListener('change', () => { drawTree(); });
              }

              if (!animationId) animationId = requestAnimationFrame(animate);

            } else {
              bgMusic.pause();
              musicBtn.textContent = 'Play Music';
            }
          });
        }
function resizeCanvases() {
    const dpr = window.devicePixelRatio || 1;
    const timerDisplay = timerCanvas.getBoundingClientRect();
    const treeDisplay = treeCanvas.getBoundingClientRect();
    timerCanvas.width = Math.max(200, Math.floor(timerDisplay.width * dpr));
    timerCanvas.height = Math.max(100, Math.floor(Math.max(timerDisplay.height, timerDisplay.width * 0.35) * dpr));
    treeCanvas.width = Math.max(100, Math.floor(treeDisplay.width * dpr));
    treeCanvas.height = Math.max(100, Math.floor(Math.max(treeDisplay.height, treeDisplay.width * 1.6) * dpr));
    timerCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
    treeCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
    const desiredWidth = timerCanvas.clientWidth * 0.9;
    const charCount = 8;
    PIXEL_SIZE = Math.max(4, Math.floor(desiredWidth / (charCount * DIGIT_WIDTH)));
    maxTreeHeight = treeCanvas.clientHeight - 50;
    const currentRemaining = timeLeft > 0 ? Math.max(0, timeLeft - (isRunning ? (Date.now() - startTime + pausedTime) : 0)) : 0;
    drawTime(formatTime(currentRemaining));
    drawTree();
}      
    window.addEventListener('resize', resizeCanvases);
      timerCanvas.style.width = '';
      treeCanvas.style.width = '';
      const style = document.createElement('style');
      style.textContent = '#timerCanvas{flex:3;min-width:220px;} #treeCanvas{flex:1;min-width:90px;} .display-container{gap:2rem;}';
      document.head.appendChild(style);
      treeHeight = 0;
      drawTime('00:00:00');
      setTimeout(resizeCanvases, 50);
    });
  </script>
</body>
</html>

\\ made by Maya Hazarika w/ help from Gemini and Copilot: maya.l.hazarika@gmail.com \\